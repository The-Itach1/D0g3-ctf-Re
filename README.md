# D0g3-ctf-Re
最近出的re题目和本人总结的一些解题脚本

## 实验班和二次招新道格杯的出题 ##
一共出了5道题，开源在github上。

### simple1 ###
简单的异或
### simple2 ###
花指令和变表base64.
### simple3 ###
自我创建进程反调试，和xxtea。
### Crackme

题目难度：中

hint：这个节区名称怎么有点奇怪？

#### 考点：

修改了upx节区名称的upx加壳，mfc，NtQueryInformationProcess反调试，Wincrypt.h库的加密函数

题目地址：[https://pan.baidu.com/s/1wHMTcIjpzA9eHbWx_JcZtg](https://pan.baidu.com/s/1wHMTcIjpzA9eHbWx_JcZtg) 提取码：abcd

#### wp：

先upx脱壳，将节区名称修改为大写的UPX，然后用upx脱壳，或者采用手脱壳的方式，这里发现，无论哪种方式，脱壳后的exe文件无法运行，所以造成了无法调试的情况，对于Mfc程序来说，这将是比较痛苦的，但是也不是不能分析，熟悉32位upx加壳原理的话，都知道调试到最后的jmp就已经完成了对程序的解密，所以完全可以结合脱壳后的文件，找到关键函数，然后使用原未脱壳的文件进行调试，使用alt+b搜索特征而定位到check函数，然后进行调试。

当然check函数前是有个NtQueryInformationProcess反调试的，这里保留了ntdll这个字符串来方便定位。

加密过程就是10bytekey 5个一组，一组进行md5，一组进行sha1，然后进行验证，验证的密文需要非调试状态才会是正确的。

然后将10byte进行md5加密，作为aes的key。

后面进行对flag进行aes加密。

```C

	#include <Windows.h>
	#include<stdio.h>
	bool AesDecrypt(BYTE* pPassword, DWORD dwPasswordLength, BYTE* pData, DWORD& dwDataLength, DWORD dwBufferLength)
	{
		// TODO: 在此处添加实现代码.
		BOOL bRet = TRUE;
		HCRYPTPROV hCryptProv = NULL;
		HCRYPTHASH hCryptHash = NULL;
		HCRYPTKEY hCryptKey = NULL;
	
		do
		{
			// 获取CSP句柄
			bRet = CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);
			if (FALSE == bRet)
			{
				break;
			}
	
			// 创建HASH对象
			bRet = CryptCreateHash(hCryptProv, CALG_MD5, NULL, 0, &hCryptHash);
			if (FALSE == bRet)
			{
	
				break;
			}
	
			// 对密钥进行HASH计算
			bRet = CryptHashData(hCryptHash, pPassword, dwPasswordLength, 0);
			if (FALSE == bRet)
			{
	
				break;
			}
	
			// 使用HASH来生成密钥
			bRet = CryptDeriveKey(hCryptProv, CALG_AES_128, hCryptHash, CRYPT_EXPORTABLE, &hCryptKey);
			if (FALSE == bRet)
			{
	
				break;
			}
	
			// 解密数据
			bRet = CryptDecrypt(hCryptKey, NULL, TRUE, 0, pData, &dwDataLength);
			if (FALSE == bRet)
			{
	
				break;
			}
	
		} while (FALSE);
	
		// 关闭释放
		if (hCryptKey)
		{
			CryptDestroyKey(hCryptKey);
		}
		if (hCryptHash)
		{
			CryptDestroyHash(hCryptHash);
		}
		if (hCryptProv)
		{
			CryptReleaseContext(hCryptProv, 0);
		}
	
		return bRet;
		return false;
	}
	
	
	
	int main()
	{
		BYTE Enc[] = { 0x35,0xf8,0x84,0x29,0x96,0x4f,0x82,0x6b,0x70,0xfe,0x3a,0xff,0x47,0x2f,0x43,0x4b,0x2c,0x68,0xbd,0x16,0x27,0x30,0x82,0x50,0xa9,0x11,0x99,0xf1,0xa0,0x44,0x20,0xc2,0x40,0x18,0x6f,0x5d,0x5b,0xd8,0x4d,0x05,0x44,0x3c,0xb5,0xe7,0x2e,0x87,0x79,0xee };
		BYTE Key[] = { 0x44,0x4f,0x8c,0xdc,0xbb,0xb7,0xcb,0x47,0x69,0x3c,0xa9,0x09,0x08,0x70,0xbc,0x40 };
		
		DWORD Enclen = 0x30;
		AesDecrypt(Key, 16, Enc, Enclen, MAX_PATH);
	
		for (int i = 0; i < Enclen; i++)
		{
			printf("%c", Enc[i]);
		}
		
	}
	//D0g3{H@sh_a^d_Aes_6y_W1nCrypt!!}
```

这道题我是在给das四月赛出的题在进行了部分修改，看雪上还有一个hook的解法，感觉还不错，原理是钩取了CryptEncrypt，将其变为了CryptDecrypt，然后打印出解密后的字符串。

### Keyboard

题目难度：中

hint：注意题目名称，keyboard，keyboard，keyboard，重要的事情说3遍！！！

题目链接：链接：[https://pan.baidu.com/s/10oHTA2tr1ztxnsLjHmIojQ](https://pan.baidu.com/s/10oHTA2tr1ztxnsLjHmIojQ)  提取码：abcd

题目文本：请将得到的字符串进行32位小写md5加密，然后加上D0g3{}

#### 考点：

假流程，假的加密过程为一个rc4加密，真正的过程是一个线程，里面有键盘钩取，钩取wasd键，进行走迷宫，但有一个tls函数对于迷宫的行列进行了变换，而且对迷宫的一个值进行了修改，里面还有一个汇编写的IsDebugPrevent反调试，也是对列行进行初始化，是错误的引导。迷宫有多条路径，需要写脚本进行走迷宫，得到最短路径。

#### wp

得到正确的迷宫后，写出脚本

```C

	#include<stdio.h>
	#include<stdlib.h>
	
	char  map[40][40] = {
	{0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, },
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 2, }, };
	
	int mark[40][40] = { 0 };
	char way[400];
	int index = 0;
	
	void check(int x, int y)
	{
		if (map[x][y] == 2)
		{
			printf("\nway: %s\n", way);
	
			printf("\n%d", index);
			//exit(0);
		}
	}
	void dfs(int x, int y)
	{
		int xnew = 0, ynew = 0;
		check(x, y);//判断走到终点。
	
		xnew = x - 1;
		ynew = y;
	
		if (xnew >= 0 && xnew < 40 && ynew >= 0 && ynew < 40 && map[xnew][ynew] != 1 && mark[xnew][ynew] != 1)//不能越界，不能撞墙，不能走以访问路线。
		{
			way[index++] = 'w';//保存路线，以便输出路线。
			mark[x][y] = 1;//标记以访问路线，避免重复访问。
			dfs(xnew, ynew);
			mark[x][y] = 0;//如果该路不能到达终点，回溯时要将标记还原。
			way[--index] = ' ';//路线走不通，还原。
		}
	
		xnew = x;
		ynew = y + 1;
		if (xnew >= 0 && xnew < 40 && ynew >= 0 && ynew < 40 && map[xnew][ynew] != 1 && mark[xnew][ynew] != 1)
		{
			way[index++] = 'd';
			mark[x][y] = 1;
			dfs(xnew, ynew);
			mark[x][y] = 0;
			way[--index] = ' ';
		}
	
		xnew = x + 1;
		ynew = y;
		if (xnew >= 0 && xnew < 40 && ynew >= 0 && ynew < 40 && map[xnew][ynew] != 1 && mark[xnew][ynew] != 1)
		{
			way[index++] = 's';
			mark[x][y] = 1;
			dfs(xnew, ynew);
			mark[x][y] = 0;
			way[--index] = ' ';
		}
	
		xnew = x;
		ynew = y - 1;
		if (xnew >= 0 && xnew < 40 && ynew >= 0 && ynew < 40 && map[xnew][ynew] != 1 && mark[xnew][ynew] != 1)
		{
			way[index++] = 'a';
			mark[x][y] = 1;
			dfs(xnew, ynew);
			mark[x][y] = 0;
			way[--index] = ' ';
		}
	
	
	
	}
	int main()
	{
		int i, j;
	
		//printf("%d %d \n", map[24][25], map[20][23]);
		map[24][25] = 0;
		//map[20][23] = 1;
		dfs(2, 2);
	}
```
得道最短路径：sdsdddwdddsssssaassdddddddwdddsssddddsssddssssssdsssddsssassdddwwwwwwwddddssdsssdsssssaaasssdsddddwddssssd
然后进行md5加密，套上D0g3{}

由于键盘钩取无法确定字符串的大小写问题，所以默认全部大写，或者默认全部小写。

全部大写的flag：D0g3{1bf4c14e20c7f8559f0c72ad4605c8d5}

全部小写的flag: D0g3{53df848a34fe32ec80b67f8f082928e9}
